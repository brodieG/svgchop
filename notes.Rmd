## Not Supported

* Text
* Mixed units (no unit conversion whatsoever), all lengths are assumed to be in
  the user coordinate system (pixels?).
* Nested SVG viewports are "ignored", which means that they are drawn without
  any transformations and thus will not display as intended if any of the x, y,
  width, height, or viewBox attributes are specified.  This information is
  preserved in the recursive 'svg_chopped' structure so can be recovered and
  used (e.g. with grid viewports) if the user so desires.
* Gradients
* Clip-paths
* Patterns
* Some elements
* CSS transforms

## ToDo

* Make sure "none" and "transparent" are reflected appropriately in fill and
  stroke.  More generally compute the defaults ourselves so whatever rendering
  happens later doesn't have to worry about SVG specific defaults.
* Add the remaining shapes?
* Think more carefully about how we want to handle path closing.  Should only
  explicitly closed paths be marked as closed (YES)?  Should open paths be drawn
  with both a polypath with NA stroke and a line to replicate how they are
  rendered by SVG renderers (MAYBE - not worth spending a lot of time on the
  plot method)?
* Add a "not supported" condition and generally let the code run through to the
  extent possible.
* "oddeven" etc. fill rules
* Should have option not to apply transforms, or make it an explicit
  post-process option in case some rendering interfaces prefer to receive that
  transform matrix directly.  Applying transform will need to recompute the
  extents.
* When implementing patterns, will need to think about whether to apply them
  truly (i.e. replace target with tessellated and clipped pattern, or just
  compute the un-transformed pattern).


## Gradients

Do we care where the gradients are?  They are supposed to be in "def" tags, but
they are ID identified so presumably we can just get the from everywhere.  From
testing the seems to be the case, so long as inside an SVG.

We need to expand the capabilities of the "fill" attribute to recognize
gradients.  One option is to leave them as they are and provide a named list
with the parsed gradient data for the renderer to use.

Gradients themselves need to have their stop values computed which may require
style sheet look-ups, and possibly inheritance from enclosing elements?

We could potentially use a simplifying (YES) assumption that we don't need to
track all the inheritance business for gradients?  It is very unlikely that a
gradient is going to be defined somewhere we care about parent properties, and
it doesn't make sense for.

Do we need to upgrade fill/stroke tracking to record the type of color we're
dealing with (pattern/gradient/color, or should it be url/color)?  Probably not
worth the hassle.  The formats are unambiguous: "url(...)" or "#xxxxxx" or
"none" so we can just have a utility function.

Patterns are far more complicated because they should have at least some limited
form of inheritance.  In fact, it seems we can place them outside of the defs
and they do inherit properties from the parents.  **Doesn't seem to inherit
transforms** in the place they are created.  The spec seems to suggest they
should if set on the pattern element itself.  They do however inherit the
tranforms of the object they are painting  So for patterns they should be
applied at the time of styling, or at least moved from the "url" list to be an
attribute of the object so that it may be transformed.  One saving grace in all
this is maybe we don't do any of this and let the display implementation figure
out how they want to apply the pattern based on the pattern directions?  Hmm,
no, we'll need to apply the transforms to the patterns as right now we provide
the actual elements transformed.  To apply patterns we really want to do so
before the transforms are done.  Applying a pattern means tiling the object,
clipping it with the object.  So the object will be replaced with a recursive
structure of clipped elements.  Once that is all done the transformation can be
carried out.  Clipping and Masks should probably be treated the same way.

So:

* Collect all gradients with ids
* Compute all stop 'stop-color' and offset where the only two possible sources
  of values are the style sheet and the in-line properties (and the in-line
  style?). Also need 'stop-opacity'.  Not clear that 
* Store gradients (and possibly other things) an ID basis in a named list to be
  looked up with `url`.

Another option is to process gradients as part of the initial pass.  This has
the advantage that all properties can be inherited from parent elements (but
what would those be?  We set a "g" with "x1" values?).  Actually it seems that
most position elements are not inherited.  That makes sense since the outer
element would control positioning then.  So are there any things that we would
want to inherit?  On the whole it doesn't seem adding the wrinkle that we could
end up with terminal leaves other than matrices.

Does this apply to patterns?  Maybe, again unlikely that they will be nested,
although since they do specify real elements therein they will contain matrices
of coordinates (i.e. recursive list containing matrices).  We'll want those to
be resolved normally, but not displayed.  Maybe flatten lops them off?  But it
does seem for patterns we will actually want to do the normal parsing.

What about clip paths and masks?  Since those are made up of elements we
probably want them parsed in the normal pass.

So patterns, clip paths, and masks will get all the normal property inherit
behavior, transform, wherever they are **defined**.  They then need to be
suppressed in rendering in some way / moved into the URL attribute.

Gradients though because they don't have terminal elements and we don't want the
styles applied to the terminal elements (because there are none) need to be
treated differentially.  So those just get pulled out in a separate stage.

To summarize, since gradients / patterns / clips, etc seem to inherit properties
to some extent from their own parents rather than where they are referenced
(except for transforms which they seem exempted from) it makes most sense to:

1. Do early processing (coord and style computation)  with them in place
    * This means non-matrix elements get to be terminal too, temporarily.
2. Remove them from the tree and into an auxillary list, while applying
   additional computations that can be done in isolation.
3. Re-attach them to the tree at the appropriate places.
    * For patterns that will may mean replacing the referencing object with the
      clipped pattern
    * For clip paths it may mean clipping the referencing object
4. (optional) Apply the transforms
    * If the pattern was not applied, do we transform the pattern?  Probably not
      as the only point of not applying the pattern is to make it available to a
      device that woudl apply it before transformation.

   , including styling.  Once that's done,
they should be moved to an external list

## Styles

### Questions

* Are in line attribute inherited by children?  Probably same as html.  Or maybe
  only via the "currentColor" value for the fill/stroke params?  Update,
  elements to inherit whatever "<g>" element properties are set.

### Basics

* Inline styles are lower priority than style sheets others
* Style sheets could appear anywhere

### Strategy:

Use "find" or whatever to get all the style sheets, and then parse them into a
structure that can be looked up by some limited implementation of selectors.
Most natural would be to focus on the very simple "only class" selectors, which
would work for our purposes in the SVGs we've seen so far.

Then

* Recursively traverse our tree, tracking:
    * latest seen in-line values for the supported style properties
    * the class chain up to that point
* When we hit a leaf, add this set to the back of the lookup structure.
* Then do the lookup for each of the properties in question

So the structure needs, for each property that we care about, a lookup table.

So probably a:

* list
* named by property
* containing named character:
    * names are the classes
    * values are the 
* with in first position an unnamed element that corresponds to the most recent
  inlined value for that property.

What about inlined "style" property?  That probably needs to go at the end, but
we need a special name for it to match?  Or maybe we just do a two pass thing
where we grab the inline style property first since we know it will dominate.

Then:

* for each element
* for each property
* match accumulated class vector against property class vector and take the
  highest index, and have match return 1 for no-match, so that the inlined
  element at position one is taken if no classes match.
* attach the full computed style to the node (matrix) in question as a specially
  named attribute unlikely to conflict ("style-computed"?).




## Recursive Travel

* Start at svg element
* Get children
* If 'g':
    * Append transform to existing
    * Append class to existing record classes
* If 'path/rect/poly' etc:
    * Append transform to exiting
    * Append class to existing
    * Convert coords fully to line segments
    * Apply transforms

Do we keep the list structure?  It's most useful for computing final style,
transform, whatever, so if for each element we can recover all that information
we don't have to worry about keeping the full list structure.

So essentially apply everything recursively, including transforms, maybe
clip-paths, record, classes, etc.  At the end flatten everything to a list
containing coords.

Do we apply clip paths?  Package [polyclip][4] may help with this.  Let's hold
off for now and maybe only do an ad-hoc clip as it looks like properly
implementing this will be pretty rough.

[4]: https://github.com/baddstats/polyclip

## Arcs

[Mortoray post][1] on computing the center from the SVG parameters seems like a
useful starting point.  He also links to the full [FUSE implementation][2] to
BÃ©zier curves but that looks like it might be challenging to port without
understanding the semantics of that program (e.g. `EllipticArcToBezierCurve`
shows up twice with different signatures in the same class).

[1]: https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/
[2]: https://github.com/fuse-open/fuselibs/blob/ee4df9deacb400211bcc30bbd11cfa6ccf787888/Source/Fuse.Drawing.Surface/SurfaceUtil.uno

Rather than beziers we can just draw segments connecting projections onto the
ellipse at regular angles, though we'll have to solve the intersection of the
ellipse with the spokes?  No, if we know rx and ry (which we will?) then we can
just use the cos/sin business to draw the ellipses.  Rotation around the x axis
remains to be accounted for.

Mortoray uses the [SVG appendix][3].  Unfortunately the latter appears to have
lost all it's images.

[3]: https://www.w3.org/Graphics/SVG/1.1/implnote.html#ArcImplementationNotes

```
```

## d.theta

Main issue right now is we're not getting the right sweep angle.  As best we can
tell the computations in 6.5.6 are causing us to go from the small arc in
reverse to the big arc by subtracting the 360 degrees, when really what we want
to do is change the direction we draw in.  The calculations are likely to return
the small arc for the angle difference between `c->p1` and `c->p2`, so we should
use the small/big flag in conjunction with the direction to figure out what to
draw.

Something is getting mixed up along the way.  Hard to believe the formulas are
wrong, but our use of the angles we get out must be wrong in some way.

Need to see if there are more implementation notes, in particular how to
interpret d.theta.

