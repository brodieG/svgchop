
## ToDo

* Separate parsing SVG from parsing an HTML file so we may deal with the
  multi-SVG in an HTML page more gracefully, although need to recover styles
  that may be outside of the SVG (yes)?

## Overall strategy

We can now parse a single SVG node, but a page may contain multiple SVG nodes,
and there may be styles on the page and in the nodes.  Looks like the style is
completely global, so that's okay.

So:

* Collect and process all CSS style sheets.
* Collect all SVG objects.
* For each SVG object, process, passing along the global style sheet object

Interface is thus:

* `process_file` (with a URL)
* `process_svg(, style)`
    * `parse_svg`
    * `transform_svg`
    * `style_svg`

Other operations

* `flatten`
* `plot`

## Transparency

May need special tracking of opacity to ensure that we track all of them accrued
across all classes / elements.

## Styles

### Questions

* Are in line attribute inherited by children?  Probably same as html.  Or maybe
  only via the "currentColor" value for the fill/stroke params?  Update,
  elements to inherit whatever "<g>" element properties are set.

### Basics

* Inline styles are lower priority than style sheets others
* Style sheets could appear anywhere

### Strategy:

Use "find" or whatever to get all the style sheets, and then parse them into a
structure that can be looked up by some limited implementation of selectors.
Most natural would be to focus on the very simple "only class" selectors, which
would work for our purposes in the SVGs we've seen so far.

Then

* Recursively traverse our tree, tracking:
    * latest seen in-line values for the supported style properties
    * the class chain up to that point
* When we hit a leaf, add this set to the back of the lookup structure.
* Then do the lookup for each of the properties in question

So the structure needs, for each property that we care about, a lookup table.

So probably a:

* list
* named by property
* containing named character:
    * names are the classes
    * values are the 
* with in first position an unnamed element that corresponds to the most recent
  inlined value for that property.

What about inlined "style" property?  That probably needs to go at the end, but
we need a special name for it to match?  Or maybe we just do a two pass thing
where we grab the inline style property first since we know it will dominate.

Then:

* for each element
* for each property
* match accumulated class vector against property class vector and take the
  highest index, and have match return 1 for no-match, so that the inlined
  element at position one is taken if no classes match.
* attach the full computed style to the node (matrix) in question as a specially
  named attribute unlikely to conflict ("style-computed"?).




## Recursive Travel

* Start at svg element
* Get children
* If 'g':
    * Append transform to existing
    * Append class to existing record classes
* If 'path/rect/poly' etc:
    * Append transform to exiting
    * Append class to existing
    * Convert coords fully to line segments
    * Apply transforms

Do we keep the list structure?  It's most useful for computing final style,
transform, whatever, so if for each element we can recover all that information
we don't have to worry about keeping the full list structure.

So essentially apply everything recursively, including transforms, maybe
clip-paths, record, classes, etc.  At the end flatten everything to a list
containing coords.

Do we apply clip paths?  Package [polyclip][4] may help with this.  Let's hold
off for now and maybe only do an ad-hoc clip as it looks like properly
implementing this will be pretty rough.

[4]: https://github.com/baddstats/polyclip

## Arcs

[Mortoray post][1] on computing the center from the SVG parameters seems like a
useful starting point.  He also links to the full [FUSE implementation][2] to
BÃ©zier curves but that looks like it might be challenging to port without
understanding the semantics of that program (e.g. `EllipticArcToBezierCurve`
shows up twice with different signatures in the same class).

[1]: https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/
[2]: https://github.com/fuse-open/fuselibs/blob/ee4df9deacb400211bcc30bbd11cfa6ccf787888/Source/Fuse.Drawing.Surface/SurfaceUtil.uno

Rather than beziers we can just draw segments connecting projections onto the
ellipse at regular angles, though we'll have to solve the intersection of the
ellipse with the spokes?  No, if we know rx and ry (which we will?) then we can
just use the cos/sin business to draw the ellipses.  Rotation around the x axis
remains to be accounted for.

Mortoray uses the [SVG appendix][3].  Unfortunately the latter appears to have
lost all it's images.

[3]: https://www.w3.org/Graphics/SVG/1.1/implnote.html#ArcImplementationNotes

```
```

## d.theta

Main issue right now is we're not getting the right sweep angle.  As best we can
tell the computations in 6.5.6 are causing us to go from the small arc in
reverse to the big arc by subtracting the 360 degrees, when really what we want
to do is change the direction we draw in.  The calculations are likely to return
the small arc for the angle difference between `c->p1` and `c->p2`, so we should
use the small/big flag in conjunction with the direction to figure out what to
draw.

Something is getting mixed up along the way.  Hard to believe the formulas are
wrong, but our use of the angles we get out must be wrong in some way.

Need to see if there are more implementation notes, in particular how to
interpret d.theta.

