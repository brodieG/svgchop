
## Not Supported

* Text
* Mixed units (no unit conversion whatsoever), all lengths are assumed to be in
  the user coordinate system (pixels?).
* Nested SVG viewports are "ignored", which means that they are drawn without
  any transformations and thus will not display as intended if any of the x, y,
  width, height, or viewBox attributes are specified.  This information is
  preserved in the recursive 'svg_chopped' structure so can be recovered and
  used (e.g. with grid viewports) if the user so desires.
* Gradients
* Clip-paths (polyclip?)  Applied before transforms?
* Patterns
* Some elements
* CSS transforms

## ToDo

* Do we actually support `use_svg`

* Add a "not supported" condition and generally let the code run through to the
  extent possible.

* Include mixed units in the "not supported" alerts, or maybe just non-pixel
  units.

* Check that transform=FALSE actually works (not sure it does).

* Add a mechanism to apply transform ex-post (including recomputing extents).

* When implementing patterns, will need to think about whether to apply them
  truly (i.e. replace target with tessellated and clipped pattern, or just
  compute the un-transformed pattern).

## Lit Review

On further inspection, seems like there is some stuff we could have used from
NPM to first compute the "cannonicalized" (C only) shape, and then breaking it
up:

* https://github.com/mattdesl/svg-mesh-3d
* https://github.com/jkroso/normalize-svg-path/blob/master/index.js
* https://github.com/fontello/svgpath

Would have saved re-implementing some stuff.

## Gradients

Do we care where the gradients are?  They are supposed to be in "def" tags, but
they are ID identified so presumably we can just get the from everywhere.  From
testing the seems to be the case, so long as inside an SVG.

We need to expand the capabilities of the "fill" attribute to recognize
gradients.  One option is to leave them as they are and provide a named list
with the parsed gradient data for the renderer to use.

Gradients themselves need to have their stop values computed which may require
style sheet look-ups, and possibly inheritance from enclosing elements?

We could potentially use a simplifying (YES) assumption that we don't need to
track all the inheritance business for gradients?  It is very unlikely that a
gradient is going to be defined somewhere we care about parent properties, and
it doesn't make sense for.

Do we need to upgrade fill/stroke tracking to record the type of color we're
dealing with (pattern/gradient/color, or should it be url/color)?  Probably not
worth the hassle.  The formats are unambiguous: "url(...)" or "#xxxxxx" or
"none" so we can just have a utility function.

Patterns are far more complicated because they should have at least some limited
form of inheritance.  In fact, it seems we can place them outside of the defs
and they do inherit properties from the parents.  **Doesn't seem to inherit
transforms** in the place they are created.  The spec seems to suggest they
should if set on the pattern element itself.  They do however inherit the
tranforms of the object they are painting  So for patterns they should be
applied at the time of styling, or at least moved from the "url" list to be an
attribute of the object so that it may be transformed.  One saving grace in all
this is maybe we don't do any of this and let the display implementation figure
out how they want to apply the pattern based on the pattern directions?  Hmm,
no, we'll need to apply the transforms to the patterns as right now we provide
the actual elements transformed.  To apply patterns we really want to do so
before the transforms are done.  Applying a pattern means tiling the object,
clipping it with the object.  So the object will be replaced with a recursive
structure of clipped elements.  Once that is all done the transformation can be
carried out.  Clipping and Masks should probably be treated the same way.

So:

* Collect all gradients with ids
* Compute all stop 'stop-color' and offset where the only two possible sources
  of values are the style sheet and the in-line properties (and the in-line
  style?). Also need 'stop-opacity'.  Not clear that 
* Store gradients (and possibly other things) an ID basis in a named list to be
  looked up with `url`.

Another option is to process gradients as part of the initial pass.  This has
the advantage that all properties can be inherited from parent elements (but
what would those be?  We set a "g" with "x1" values?).  Actually it seems that
most position elements are not inherited.  That makes sense since the outer
element would control positioning then.  So are there any things that we would
want to inherit?  On the whole it doesn't seem adding the wrinkle that we could
end up with terminal leaves other than matrices.

Does this apply to patterns?  Maybe, again unlikely that they will be nested,
although since they do specify real elements therein they will contain matrices
of coordinates (i.e. recursive list containing matrices).  We'll want those to
be resolved normally, but not displayed.  Maybe flatten lops them off?  But it
does seem for patterns we will actually want to do the normal parsing.

What about clip paths and masks?  Since those are made up of elements we
probably want them parsed in the normal pass.

So patterns, clip paths, and masks will get all the normal property inherit
behavior, transform, wherever they are **defined**.  They then need to be
suppressed in rendering in some way / moved into the URL attribute.

Gradients though because they don't have terminal elements and we don't want the
styles applied to the terminal elements (because there are none) need to be
treated differentially.  So those just get pulled out in a separate stage.

To summarize, since gradients / patterns / clips, etc seem to inherit properties
to some extent from their own parents rather than where they are referenced
(except for transforms which they seem exempted from) it makes most sense to:

1. Do early processing (coord and style computation)  with them in place
    * This means non-matrix elements get to be terminal too, temporarily.
2. Remove them from the tree and into an auxillary list, while applying
   additional computations that can be done in isolation.
3. Re-attach them to the tree at the appropriate places.
    * For patterns that will may mean replacing the referencing object with the
      clipped pattern
    * For clip paths it may mean clipping the referencing object
4. (optional) Apply the transforms
    * If the pattern was not applied, do we transform the pattern?  Probably not
      as the only point of not applying the pattern is to make it available to a
      device that woudl apply it before transformation.

   , including styling.  Once that's done,
they should be moved to an external list

## Presentation

`clean` in particular will modify the object structure j
Really need to think about what we're trying to do here.  The right thing
rather than clean might be a better print or str or summary method.

What do we want to see?  Maybe the original structure with all the cruft
taken off and some indication of class and size?  Should those be summary
methods?  Yes, we'll want a summary method for the normal one with the full
structure, and one for the flattened one.  The purpose of the flattened one
is to make it easier to pull out objects by indexing.  Although in theory we
could also index the full thing?

      [[c(1,1)]]   <svg>
      [[c(1,1,1)]]     <g>
      [[c(1,1,1,1)]]       <rect class='cls-1' x1 y1 x2 y2>
      [[c(1,1,1,2)]]       <path class='cls-2' 230 coords, 500 x 500>
      [[c(1,1,2)]]     <g>

Problem is likely to be that the indices will get too big too fast and won't
leave room for the rest.  In which case there is only a summary method for
the flattened version, which I'm guessing makes most sense?



## Arcs

[Mortoray post][1] on computing the center from the SVG parameters seems like a
useful starting point.  He also links to the full [FUSE implementation][2] to
BÃ©zier curves but that looks like it might be challenging to port without
understanding the semantics of that program (e.g. `EllipticArcToBezierCurve`
shows up twice with different signatures in the same class).

[1]: https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/
[2]: https://github.com/fuse-open/fuselibs/blob/ee4df9deacb400211bcc30bbd11cfa6ccf787888/Source/Fuse.Drawing.Surface/SurfaceUtil.uno

Rather than beziers we can just draw segments connecting projections onto the
ellipse at regular angles, though we'll have to solve the intersection of the
ellipse with the spokes?  No, if we know rx and ry (which we will?) then we can
just use the cos/sin business to draw the ellipses.  Rotation around the x axis
remains to be accounted for.

Mortoray uses the [SVG appendix][3].  Unfortunately the latter appears to have
lost all it's images.

[3]: https://www.w3.org/Graphics/SVG/1.1/implnote.html#ArcImplementationNotes

```
```

