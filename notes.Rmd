## Not Supported

* Mixed units (no unit conversion whatsoever), all lengths are assumed to be in
  the user coordinate system (pixels?).
* SVG viewports are ignored
* Nested SVG viewports are ignored (could support via grid viewports - clearly
  there is a lot of similarities between SVG and grid viewports)
* Clip-paths
* Some elements
* Some transforms
* CSS transforms

## ToDo

* Add all transforms (and test with files that use them)
* Add the remaining shapes?
* Plot methods (how do we plot multiple svg elements?).  They can nest!
  Actually, that's a big deal; we need to make sure that we don't retrieve
  nested SVG elements.  We could just traverse the whole document looking for
  SVG elements tracking whether we are top level or not.  Or we need to figure
  out the selector to pull out SVGs that are not nested in SVGs (better).

## Display Port

Scenarios to consider:

* width & height & viewBox
* (width | height) & viewBox
* width & height
* width | height

If width and height are missing, then presumably the viewBox will expand to
fill whatever space it needs, which will be determined by the width/height of
the viewBox.  If those are not specified, then we can compute the extents of the
object.

So for each of width / height:

* If specified as SVG width / height, use that
* Else If specified as viewBox, use that
* Else If Xmin/Ymin specified in viewBox:
   * Compute extent and subtract max extent from min value
* Else compute extent and take max value (effectively assume 0 is default X/Ymin)

Or maybe we don't care about viewbox / viewport?  Just record those and return
them as the extent.

Do we return the whole thing flat?  Or recursive?  All attributes attached?

Add the option to flatten?  Or make that a separate function?  Probably a
separate function.

* svg_chopped
* svg_chopped_flat

Plot methods for the two, and for:

* svg_chopped_list

Do we keep the `xml_attrs`?  Useful for debugging, but do we actually need them?
Maybe we keep them for the tree, but not for flat by default?  Is it weird to
have different settings for the two?

## Overall strategy

We can now parse a single SVG node, but a page may contain multiple SVG nodes,
and there may be styles on the page and in the nodes.  Looks like the style is
completely global, so that's okay.

So:

* Collect and process all CSS style sheets.
* Collect all SVG objects.
* For each SVG object, process, passing along the global style sheet object

Interface is thus:

* `process_file` (with a URL)
* `process_svg(, style)`
    * `parse_svg`
    * `transform_svg`
    * `style_svg`

Other operations

* `flatten`
* `plot`

## Transparency

Transparency rules seem to be:

* compute transparency of element from:
    * style sheet
    * inline style
    * attribute
    * winner takes all
* Look back at pre-computed chain of transparency


May need special tracking of opacity to ensure that we track all of them accrued
across all classes / elements.  These definitely nest.

## Styles

### Questions

* Are in line attribute inherited by children?  Probably same as html.  Or maybe
  only via the "currentColor" value for the fill/stroke params?  Update,
  elements to inherit whatever "<g>" element properties are set.

### Basics

* Inline styles are lower priority than style sheets others
* Style sheets could appear anywhere

### Strategy:

Use "find" or whatever to get all the style sheets, and then parse them into a
structure that can be looked up by some limited implementation of selectors.
Most natural would be to focus on the very simple "only class" selectors, which
would work for our purposes in the SVGs we've seen so far.

Then

* Recursively traverse our tree, tracking:
    * latest seen in-line values for the supported style properties
    * the class chain up to that point
* When we hit a leaf, add this set to the back of the lookup structure.
* Then do the lookup for each of the properties in question

So the structure needs, for each property that we care about, a lookup table.

So probably a:

* list
* named by property
* containing named character:
    * names are the classes
    * values are the 
* with in first position an unnamed element that corresponds to the most recent
  inlined value for that property.

What about inlined "style" property?  That probably needs to go at the end, but
we need a special name for it to match?  Or maybe we just do a two pass thing
where we grab the inline style property first since we know it will dominate.

Then:

* for each element
* for each property
* match accumulated class vector against property class vector and take the
  highest index, and have match return 1 for no-match, so that the inlined
  element at position one is taken if no classes match.
* attach the full computed style to the node (matrix) in question as a specially
  named attribute unlikely to conflict ("style-computed"?).




## Recursive Travel

* Start at svg element
* Get children
* If 'g':
    * Append transform to existing
    * Append class to existing record classes
* If 'path/rect/poly' etc:
    * Append transform to exiting
    * Append class to existing
    * Convert coords fully to line segments
    * Apply transforms

Do we keep the list structure?  It's most useful for computing final style,
transform, whatever, so if for each element we can recover all that information
we don't have to worry about keeping the full list structure.

So essentially apply everything recursively, including transforms, maybe
clip-paths, record, classes, etc.  At the end flatten everything to a list
containing coords.

Do we apply clip paths?  Package [polyclip][4] may help with this.  Let's hold
off for now and maybe only do an ad-hoc clip as it looks like properly
implementing this will be pretty rough.

[4]: https://github.com/baddstats/polyclip

## Arcs

[Mortoray post][1] on computing the center from the SVG parameters seems like a
useful starting point.  He also links to the full [FUSE implementation][2] to
BÃ©zier curves but that looks like it might be challenging to port without
understanding the semantics of that program (e.g. `EllipticArcToBezierCurve`
shows up twice with different signatures in the same class).

[1]: https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/
[2]: https://github.com/fuse-open/fuselibs/blob/ee4df9deacb400211bcc30bbd11cfa6ccf787888/Source/Fuse.Drawing.Surface/SurfaceUtil.uno

Rather than beziers we can just draw segments connecting projections onto the
ellipse at regular angles, though we'll have to solve the intersection of the
ellipse with the spokes?  No, if we know rx and ry (which we will?) then we can
just use the cos/sin business to draw the ellipses.  Rotation around the x axis
remains to be accounted for.

Mortoray uses the [SVG appendix][3].  Unfortunately the latter appears to have
lost all it's images.

[3]: https://www.w3.org/Graphics/SVG/1.1/implnote.html#ArcImplementationNotes

```
```

## d.theta

Main issue right now is we're not getting the right sweep angle.  As best we can
tell the computations in 6.5.6 are causing us to go from the small arc in
reverse to the big arc by subtracting the 360 degrees, when really what we want
to do is change the direction we draw in.  The calculations are likely to return
the small arc for the angle difference between `c->p1` and `c->p2`, so we should
use the small/big flag in conjunction with the direction to figure out what to
draw.

Something is getting mixed up along the way.  Hard to believe the formulas are
wrong, but our use of the angles we get out must be wrong in some way.

Need to see if there are more implementation notes, in particular how to
interpret d.theta.

