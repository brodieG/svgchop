
## Arcs

[Mortoray post][1] on computing the center from the SVG parameters seems like a
useful starting point.  He also links to the full [FUSE implementation][2] to
BÃ©zier curves but that looks like it might be challenging to port without
understanding the semantics of that program (e.g. `EllipticArcToBezierCurve`
shows up twice with different signatures in the same class).

[1]: https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/
[2]: https://github.com/fuse-open/fuselibs/blob/ee4df9deacb400211bcc30bbd11cfa6ccf787888/Source/Fuse.Drawing.Surface/SurfaceUtil.uno

Rather than beziers we can just draw segments connecting projections onto the
ellipse at regular angles, though we'll have to solve the intersection of the
ellipse with the spokes?  No, if we know rx and ry (which we will?) then we can
just use the cos/sin business to draw the ellipses.  Rotation around the x axis
remains to be accounted for.

Mortoray uses the [SVG appendix][3].  Unfortunately the latter appears to have
lost all it's images.

[3]: https://www.w3.org/Graphics/SVG/1.1/implnote.html#ArcImplementationNotes

```
// Copyright (C) 2018-present Fuse Open
// Copyright (C) 2015-2018 Fusetools AS
// 
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// Code originally from: https://github.com/fuse-open/fuselibs/blob/ee4df9deacb400211bcc30bbd11cfa6ccf787888/Source/Fuse.Drawing.Surface/SurfaceUtil.uno

static float svgAngle( double ux, double uy, double vx, double vy )
{
  u <- c(X=ux, Y=uy);
  v <- c(X=vx, Y=vy);
  //(F.6.5.4)
  dot <- sum(u * v)
  # len <- Vector.Length(u) * Vector.Length(v);
  len <- sqrt(sum(u^2)) * sqrt(sum(v^2))
  #floating point precision, slightly over values appear
  ang <- acos(max(min(dot / len,1),-1)) 
  if ( (u['X']*u['Y'] - u['Y']*u['X']) < 0)
          ang <- -ang;
  ang
};
/**
        Perform the endpoint to center arc parameter conversion as detailed in
        the SVG 1.1 spec.  F.6.5 Conversion from endpoint to center
        parameterization

        @param r must be a ref in case it needs to be scaled up, as per the SVG spec
*/
internal static void EndpointToCenterArcParams(
  float2 p1,
  float2 p2,
  ref float2 r_,
  float xAngle,
  bool flagA,
  bool flagS,
  out float2 c,
  out float2 angles
)
{
  rX <- abs(r_['X'])
  rY <- abs(r_['Y'])
  xAngle <- xAngle / 180 * pi

  #(F.6.5.1)
  dx2 <- (p1['X'] - p2['X']) / 2.0;
  dy2 <- (p1['Y'] - p2['Y']) / 2.0;
  x1p <- cos(xAngle)*dx2 + sin(xAngle)*dy2;
  y1p <- -sin(xAngle)*dx2 + cos(xAngle)*dy2;

  #(F.6.5.2)
  rxs <- rX * rX;
  rys <- rY * rY;
  x1ps <- x1p * x1p;
  y1ps <- y1p * y1p;

  # check if the radius is too small `pq < 0`, when `dq > rxs * rys` (see below)
  # cr is the ratio (dq : rxs * rys)
  cr <- x1ps/rxs + y1ps/rys;
  if (cr > 1) {
    #scale up rX,rY equally so cr == 1
    s <- sqrt(cr);
    rX <- s * rX;
    rY <- s * rY;
    rxs <- rX * rX;
    rys <- rY * rY;
  }
  dq <- (rxs * y1ps + rys * x1ps);
  pq <- (rxs*rys - dq) / dq;
  q <- sqrt(max(0,pq)) #use Max to account for float precision
  if (flagA == flagS)
    q <- -q;
  cxp <- q * rX * y1p / rY;
  cyp <- - q * rY * x1p / rX;

  #(F.6.5.3)
  cx <- cos(xAngle)*cxp - sin(xAngle)*cyp + (p1['X'] + p2['X'])/2
  cy <- sin(xAngle)*cxp + cos(xAngle)*cyp + (p1['Y'] + p2['Y'])/2

  #(F.6.5.5)
  theta <- svgAngle( 1,0, (x1p-cxp) / rX, (y1p - cyp)/rY )
  #(F.6.5.6)
  delta <- svgAngle(
    (x1p - cxp)/rX, (y1p - cyp)/rY,
    (-x1p - cxp)/rX, (-y1p - cyp)/rY
  )
  delta <- (delta %% pi);
  if (!flagS) delta <- delta - 2 * pi;

  r_ <- c(rX, rY)
  c <- c(cx, cy)
  angles <- c(theta, delta)
}
```

