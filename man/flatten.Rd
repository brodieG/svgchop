% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/misc.R
\name{flatten}
\alias{flatten}
\title{Simplify "svg_chopped" Structure}
\usage{
flatten(x, ...)
}
\arguments{
\item{x}{an object to flatten}
}
\value{
the object flattened
}
\description{
\code{flatten} collapses "svg_chopped" recursive structure by placing all
non-"hidden" terminal nodes into a one level list.  Flattened
"svg_chopped_list" objects will retain distinct elements for each
"svg_chopped" contained therein, so an "svg_chopped_list_flat" object will
have two levels: one for the "svg_chopped_flat" objects, and one for the
visible terminal leaves of those.
}
\details{
When flattening terminal leaves are retrieved via depth-first recursion into
a single level list for each "svg_chopped" object.  Terminal elements
defined inside "<defs>" blocks are considered hidden and omitted from
the flat list.  Attributes for the "svg_chopped", "svg_chopped_list", and
terminal nodes are retained.

The raw names of the flat structure may not be unique, so for convenience we
prepend the numeric index of each element so you may subset with numeric
indices.

"svg_chopped_flat" (and "svg_chopped") objects are best inspected with
\code{\link[utils:str]{utils::str()}}.
}
\examples{
## Normal "svg_chopped" objects are tree-like
svg <- chop(svg_samples('shapes'))
str(svg, max.level=3, list.len=3)

## Flattened ones are linearized and lose hidden elements
svgf <- flatten(svg)
str(svgf, list.len=8)
length(svgf)          # number of distinct SVG elements

## We can use this to plot only parts of the SVG
\donttest{
old.par <- par(mfrow=c(2,2), mai=rep(.1, 4))
plot(svgf, scale=TRUE)             # full plot
plot(svgf[4], scale=TRUE)     # one item
plot(svgf[4:6], scale=TRUE)   # more
plot(svgf[10:12], scale=TRUE) # more
par(old.par)
}
}
\seealso{
\code{\link[=chop]{chop()}}
}
