% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse.R
\name{chop}
\alias{chop}
\alias{chop_all}
\title{Approximate SVG Elements  With Line Segments}
\usage{
chop(
  file,
  steps = 10,
  transform = TRUE,
  clip = TRUE,
  warn = getOption("svgchop.warn", FALSE)
)

chop_all(
  file,
  steps = 10,
  transform = TRUE,
  clip = TRUE,
  warn = getOption("svgchop.warn", FALSE)
)
}
\arguments{
\item{file}{an HTML or other XML based text file containing SVG elements.}

\item{steps}{integer(1L) > 0, how many line segments to use to approximate
Bézier curves, arcs, ellipses, and circles.  For Bézier curves, it is how
many segment each individual curve gets, so sequences of Bézier curves will
get that many for each curve in the sequence.  For arcs, ellipses, and
circles, it is how many segments per 180 degrees of arc.  The hope is that
in the future this parameter will be deprecated in favor of tolerance
based ones.}

\item{transform}{TRUE (default) or FALSE whether to apply the transformation
to the computed element coordinates.  There is a chance this parameter will
become deprecated and we will no longer provide the option to leave
transforms un-applied.  If set to FALSE, you must should also set \code{clip} to
FALSE and apply the clip-paths yourself.}

\item{clip}{TRUE (default) or FALSE whether to apply clipping paths to the
output.  See "Gradients, Patterns, Masks, and Clip Paths".}

\item{warn}{TRUE or FALSE (default) whether to warn when unsupported SVG
features are encountered.  Note the warnings are not comprehensive.  See
"Unsupported Features" section for details.}
}
\value{
an "svg_chopped" S3 object for \code{chop}, an "svg_chopped_list" S3
object for \code{chop_all}.  See "Return Value" section for details.
}
\description{
Parse and convert SVG elements into line segments and supporting meta data.
SVG transforms and clip paths are optionally applied, and SVG presentation
attributes are computed from style sheets, inline styles and attributes.  The
\href{https://www.w3.org/TR/SVG11/}{SVG 1.1 specification} is loosely followed so
expect divergences from conforming SVG rendering engines.  This function is
experimental and the API and structure of the return value will likely change
in future versions.  The code is optimized neither for speed nor memory use.
}
\section{Details}{


The primary objective of these functions is to compute vertex coordinates of
piecewise linear approximations of SVG display elements so that they may
be used elsewhere.  We wrote this code to make it easier to render extruded
SVG objects in 3D with
\href{https://cran.r-project.org/package=rayrender}{\code{rayrender}}.  See the
examples, and the implementation of \code{\link[=plot.svg_chopped]{plot.svg_chopped()}} for ideas on how
to extract the data for your own use.

In addition to vertex coordinates, this function will attempt to compute
styles using an approximation of SVG styling and CSS semantics for a
limited set of styles (see the "Styling" section).

It is likely best to start by looking at the examples for this function and
for \code{\link[=flatten]{flatten()}} to get a sense for how to interact with the outputs.
}

\section{Return Value}{


For \code{chop}, an "svg_chopped" object, a recursive list that represents the
\emph{first} top-level SVG viewport in the document.  The leaves are usually \verb{2 x n}
numeric matrices that contain the X-Y coordinates of the ordered \code{n}
endpoints of the \code{n - 1} line segments that approximate the SVG element they
represent.  These matrices will have attributes attached that modify how they
should be interpreted.  If the leaves are not known display elements they
will appear as empty lists.  There may be terminal elements that are neither
lists nor matrices (e.g. gradient "stop"s).

For "chop_all", an "svg_chopped_list" object, a list of "svg_chopped"
objects, each representing one of the top-level SVG viewport in the document.

Each leaf in the tree will have several attributes attached.  An incomplete
list of possible attributes:
\itemize{
\item "xml_attrs": the original SVG element attributes, which you may retrieve
and parse with your own logic.
\item "xml_name": the name of the SVG element.
\item "styles-computed": a list of the parsed and computed element styles (see
the "Styling" section).
\item "transform-computed": accumulated transformation data (see "Transforms"
section).
\item "starts": indicates the starting column of sub-paths in paths; paths with
embedded "M" or "m" commands will contain sub-paths.  Will always start
with 1 when present so it is the same length as "closed".  For use with
e.g. \href{https://cran.r-project.org/package=decido}{\code{decido}} you will need to
drop the first element.
\item "closed": logical vector indicating whether each subpath is closed (e.g.
ends in a "Z" or "z" command).
\item "extents": the extents of the element including clipped areas, transformed
if the transform is applied by \code{svgchop}.
\item "clip-path": if present, the clip path to apply to the element, in
\code{polyclip} format.  If you intend to manually apply the clip path to the
leaves instead of letting \code{chop} do it, you will have to collect all the
ancestor clip paths and AND combine them.  If you are manually applying the
transforms you will need to transform each clip path before combining them
and applying them (see the "Gradients, Patterns, Masks, and Clip Paths"
section).
}

Leaves that are defined within <defs> blocks will inherit from
"hidden".

Inspecting "svg_chopped*" objects is best done by starting with \code{str(obj)} as
they tend to be very complex.  This package implements \code{\link[=str]{str()}} methods that
omit attributes by default as there are many of those and it is difficult to
see the object structure with them displayed.
}

\section{Dimensions}{


"svg_chopped" objects will have "width", "height", "viewBox", and "extents"
attributes.  The first three correspond to the SVG attributes you might find
on an "svg" element.  The last is a list containing the range of X and Y
coordinates contained within the SVG display elements (after transforms if
they are applied, but before clipping).

All lengths and coordinates are assumed to be unit-less except for the
"width" and "height" attributes on the top-level SVG elements, and the
"offset" and "stop-opacity" attributes for gradient stops.  In other words
for most elements "px", "em", "cm", "\%", etc. values are completely ignored
with all lengths assumed to be in user coordinate system units.

The "width" and "height" attributes of the top-level SVG elements will be
interpreted as display device percentages if "\%" units are used, or pixels if
they are not.  The "offset" attribute to gradient stops will be interpreted
as percentages if "\%" units are used, or as unit-less numbers otherwise.

Future releases may switch to preserving units with e.g. \code{\link[grid:unit]{grid::unit()}}.
}

\section{Elements}{


The basic elements "line", "rect", "polygon", "polyline", "circle",
"ellipse", and "path" with all commands in the SVG 1.1 spec are
implemented.  "rect" does not support rounded corners, and "ellipse" does not
support "auto" values for "rx" and "ry" (that is the default, but we assume
0).  "pathLength" is not supported on any element.

XML attribute data is processed to compute X and Y coordinates for a set of
vertices that approximates the outline of each element.  These are stored as
2 x n matrices.  The attribute "closed" will be set to a logical vector
representing whether the element should be interpreted as a closed polygon or
as an open "polyline".  "path" elements may contain sub-paths, and the
"closed" vector will contain one entry for each sub-path.  The starting
column in the coordinate matrix for each sub-path is recorded in the "starts"
attribute.

The "use" element is supported, but only if the "xlink:href" or "href"
elements point to the id of an element within the same document.  Support is
also non-conforming (not that anything in this package is truly
conforming...) as CSS selector matching behaves as if the cloned copy of the
object were a full DOM child of the "use" element.  However, this
non-conformance is likely superseded by the very limited CSS selector
implementation (see "Styling" section).  The "use" element will be treated
as if it were a "g" element with the referenced element as a child and the
"x" and "y" attributes specified as a translate transform.

"g" elements behave similarly as they do in SVG documents.  Elements not
explicitly referenced here are not directly supported and how they are
processed is not specified.  Generally though such elements with children
will behave like "g" elements, and those without will be omitted.
}

\section{Transforms}{


Only SVG transforms are supported (i.e. not CSS ones).  The transform
attribute of every element in the SVG is read, parsed, and accumulated
through element generations.  It is then applied to the computed coordinates
of the terminal nodes, and to any clip paths attached to the tree (see the
"Gradients, Patterns, Masks, and Clip Paths" section).  You may turn off the
application of the transforms by setting \code{transform=FALSE}, in which case you
will be responsible for retrieving the transform data from the
"transform-computed" attribute of the terminal leaves of the "svg_chopped"
objects or the nodes that have clip paths attached.  This attribute will be a
"trans" S3 object containing the transformation matrix as the "mx" member and
the commands that were processed to produce that matrix as the "cmds" member.

"transform-computed" data is accumulated through generations, so you need not
re-fetch ancestral transforms if you are manually applying transforms.

The rendering agent is responsible for scaling stroke.  For
\code{\link[=plot.svg_chopped]{plot.svg_chopped()}} we use the average of the absolute scaling factors from
the computed transformation matrix as an approximation.
}

\section{Styling}{


A subset of the \href{https://www.w3.org/TR/SVG11/styling.html#SVGStylingProperties}{SVG 1.1 styling properties}
is explicitly computed from the SVG data (see \code{\link[=styles_computed]{styles_computed()}} for the
list).  Values are taken from the properties defined in-line in the SVG
elements or its ancestors, internal CSS style sheets, and in-line "style"
properties.  The computed style will be attached as the "style-computed"
attribute to nodes of the tree.  For inheritable styles the attribute will be
attached to the leaves of the tree (i.e the vertex coordinate matrices).  For
non inheritable styles they will be attached to the node they are defined on.

CSS selector support is limited to direct match lookups on
"&#lt;element>.<class>" or "<element>#<id>" where "*"
may be used as a wild card.  Selector hierarchies, properties, or anything
other than basic selectors is not supported.  For example, the following
selectors are supported:
\itemize{
\item "*".
\item "*.class".
\item "rect.class".
\item "rect#id".
\item ".class".
\item "#id".
}

But these are not:
\itemize{
\item "g class"        (element of class "class" a descendant of a "g" element).
\item "*.class.klass"  (two classes).
}

Style sheets are parsed with regex, so parsing may fail if you have
particularly pathological text therein.

Styles, classes, and ids are accumulated through element generations and
computed into the "styles-computed" attribute of the terminal nodes, which is
a list with scalar elements representing the computed style values.  Missing
or uncomputable styles are reported as NA, except in the cases where the spec
defines default values or it is convenient for us to assert a default.
Default values will have class "default".  The computation is an
approximation of what the spec mandates.

Fill and stroke values, with three exceptions, are returned as 6 digit
hex-codes or NA so that it is easy to append alpha values derived from the
opacity values.  Supported color formats are 6 digit hex, 3 digit hex, named
colors in \code{\link[=svg_colors_all]{svg_colors_all()}} (the 147 named SVG 1.1 colors), and \code{rgb(x,y,z)}
where \code{x}, \code{y}, and \code{z} are numeric or percentage values as per the CSS spec.
"url(#id)" values are returned as is, dropping any fallback value that
follows them.  See the "Gradients, Patterns, Masks, and Clip Paths" for more
details on how to handle "url" values.

If an element specifies both "opacity", and "stroke-opacity" or
"fill-opacity", the latter two are multiplied with the value of "opacity".
Since the "opacity" value is thus reflected in "stroke-opacity" and
"style-opacity" it is dropped to avoid confusion.
}

\section{Gradients, Patterns, Masks, and Clip Paths}{


All SVG elements that are intended to be referenced via "url(#id)" from
within other elements are extracted from the SVG tree and stored as named
elements in the list attached as the "url" attribute to the "svg_chopped" and
"svg_chopped_list" objects.  In their place in the original tree structure
will be empty lists.

A common use case for "url" elements are fill styles that use gradients.
Typically the fill will be specified as \verb{fill=url(#gradientid)}.  If you see
such a value in the "style-computed" attribute of an "svg_chopped" node, you
can use e.g. \code{attr(svg_chopped_object, 'url')[['gradientid']]} to retrieve
it.  For a usage example see \code{\link[=approximate_color]{approximate_color()}} which is used by the
"svg_chopped" plot method to approximate a gradient by a single color.

Both linear and radial gradients have limited support.  Gradients are parsed
and stop style is computed based on where they are defined.  Gradients are
attached as members of the "url" attribute of the return value.  All the
gradient coordinate values (e.g. "x", "y", "cx", "cy", ...) are assumed to be
specified in [0, 1], and not as percentages.  "gradientTransform" is
computed into a transformation matrix, but nothing else is done with it.

Clip paths are computed and attached as the "clip-path" attribute of any node
that references them.  This means that, unlike with gradients, they have
already been fetched and incorporated into the "svg_chopped" tree
(although they remain available in the "url" attribute too).  They are in the
format favored by \code{polyclip} (list with "x" and "y" elements with last point
not overlapping first).

If \code{clip} is set to TRUE (default), then the clip path will be applied to the
elements, but this will only work well with polygons.  To handle this
properly for open paths and similar you will need to run with \code{clip = FALSE},
make polygons in the shapes of the open paths, e.g. with
\code{\link[polyclip:polylineoffset]{polyclip::polylineoffset()}}, and then retrieve the clipping path from the
"clip-path" attribute to apply it yourself.

If you wish to manually apply the clip paths, you will need to retrieve all
the ancestors and AND combine them yourself.  This is unlike transforms,
which are computed accounting for ancestor transforms.  This oddity is
required to ensure that clip paths still make sense for the case where
transforms are deferred and applied manually later.
In the transform deferral case, you will need to apply the corresponding
transforms to each ancestor clip path before AND combining them.  The
transform data should be attached as the "transform-computed" attribute of
any node that also has a "clip-path" attribute.  Note that transforms on the
clip path definitions (i.e. those affecting the contents of <clipPath>
elements) will always be applied, unlike those of that affect the elements
that reference them.

"clip-path" attributes on "clipPath" elements are not followed, which is a
departure from the spec.  "clipPathUnits" are assumed to be "userSpaceOnUse".
}

\section{Unsupported Features}{


An incomplete list of known unsupported features:
\itemize{
\item Filters.
\item Masks.
\item Patterns.
\item Plotting of gradients.
\item Mixed length units, and most non user space units.
\item Rounded corners or length constraints on paths / elements.
\item CSS transforms.
\item Complex CSS selectors.
\item "rgba" color specification.
\item Clip path "clipPathUnits" other than "userSpaceOnUse".
\item Nested SVG viewports.
\item "preserveAspectRatio" values other than "meet".
}

There are other features that are either unimplemented, incompletely
implemented, or incorrectly implemented.  The parser will signal conditions
that inherit class "svgchop" when encountering some of these.  See
examples for ideas on how to use handlers to examine the problematic SVGs.

There is a distinction between features unimplemented in the parser and those
unimplemented in the \code{plot} method.  For example, gradients are mostly
implemented in the parser, but the \code{plot} method is not able to represent
them other than as a single color.

You can ask \code{chop} and \code{chop_all} to report when they encounter unsupported
features by setting \code{warn=TRUE} or `options(svgchop.warn=TRUE), although the
reporting is not comprehensive.  Both of these functions always signal
conditions inheriting class "svgchop" so you may handle them (see example).
}

\examples{
## Chop and plot to demonstrate we reproduce the logo
svg <- chop(R_logo())
if(interactive()) plot(svg)

## Let's do this manually instead of the built-in plot method
xy <- get_xy_coords(svg)
fills <- get_fills(svg)
ext <- attr(svg, "extents")
if(interactive()) {
  ## These are all base plotting commands
  plot.new()
  plot.window(ext$x, rev(ext$y), asp=1)
  polypath(xy[[1]], col=fills[[1]], border=NA)
  polypath(xy[[2]], col=fills[[2]], border=NA)
}

## Let's do it the ugly way, directly retrieving the
## data instead of relying on the helper `get_` funs.
## This is useful because the `get_` funs are limited.
str(svg) # str(svg, give.attr=TRUE) # to show attributes
hoop <-  svg[[2]]
r <-     svg[[3]]
if(interactive()) {
  ## Basic geometry; Note that coordinates are natively
  ## stored as 2 x n matrices.
  plot(
    t(hoop), type='l', ann=FALSE, asp=1, axes=FALSE,
    xlim=ext[['x']], ylim=rev(ext[['y']])
  )
  lines(t(r))
}
## All the way now, by "hand" again to show some
## details of internal data structure
if(interactive()) {
  plot.new()
  plot.window(xlim=ext[['x']], ylim=rev(ext[['y']]), asp=1)
  r2 <- r
  ## Abuse the fact we know the polygons are explicitly closed,
  ## so make the first value of each sub-path NA so they are treated
  ## as separate by polypath (`get_coords_xy` does this without
  ## abuse). We skip first index otherwise `polypath` complains.
  r2[,attr(r, 'starts')[-1]] <- NA
  polypath(t(r2), col='blue')

  ## Color not right, let's retrieve actual color
  rfill <- attr(r, 'style-computed')[['fill']]
  rfill
  ## Gah, it's a gradient.  But we can approximate the color.
  rfill <- approximate_color(rfill, attr(svg, 'url'))
  plot.new()
  plot.window(xlim=ext[['x']], ylim=rev(ext[['y']]), asp=1)
  polypath(t(r2), col=rfill)
}
if(interactive()) {
  ## We control the geometry, so let's play by drawing the full
  ## logo but applying arbitrary transforms (note: SVG transforms
  ## are applied automatically).
  h2 <- hoop
  h2[, attr(hoop, 'starts')[-1]] <- NA
  hfill <- attr(hoop, 'style-computed')[['fill']]
  hfill <- approximate_color(hfill, attr(svg, 'url'))
  ## rotation matrices
  ang <- pi/16
  center <- vapply(ext, mean, 0)
  rot1 <- matrix(c(cos(ang), sin(ang), -sin(ang), cos(ang)), 2)
  rot2 <- matrix(c(cos(-ang), sin(-ang), -sin(-ang), cos(-ang)), 2)
  plot.new()
  plot.window(xlim=ext[['x']], ylim=rev(ext[['y']]), asp=1)
  polypath(t(rot2 \%*\% (h2 - center) + center), col=hfill)
  polypath(t(rot1 \%*\% (r2 - center) + center), col=rfill)
}
## Run with handlers to intercept errors
\dontrun{
withCallingHandlers(
  svg_gallery(svg_samples('pie-and-arcs')),

  ## set a handler on 'svgchop' signals, and
  ## inspect stack at moment of problem
  svgchop=function(e) recover()
)
}
}
\seealso{
\code{\link[=plot.svg_chopped]{plot.svg_chopped()}}, \code{\link[=flatten]{flatten()}} for an easier-to-manage data
structure, \code{\link[=get_xy_coords]{get_xy_coords()}} for an easy way to get some basic data out of
the "svg_chopped" objects, \code{\link[=styles_computed]{styles_computed()}} for what styles are actively
processed, \code{\link[=approximate_color]{approximate_color()}} for how to approximate gradient fills.
}
