% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse.R
\name{process_svg}
\alias{process_svg}
\title{Convert SVG Elements to Polygons}
\usage{
process_svg(file, steps = 10, transform = TRUE)
}
\arguments{
\item{file}{an HTML or other XML based text file containing SVG elements.}

\item{steps}{integer(1L) > 0, how many line segments to use to approximate
Bézier curves, arcs, ellipses, and circles.  For Bézier curves, it is how
many segment each individual curve gets, so sequences of Bézier curves will
get that many for each curve in the sequence.  For arcs, ellipses, and
circles, it is how many segments per 360 degrees of arc.  The hope is that
in the future this parameter will be deprecated in favor of tolerance
based ones.}

\item{transform}{TRUE (default) or FALSE whether to apply the transformation
to the computed element coordinates.}
}
\value{
an "svg_chopped_list" S3 object, which is a list of "svg_chopped"
objects.  Each "svg_chopped" object represents a top level SVG viewport the
dimensions of which are recorded in the "box" attribute.  "svg_chopped"
objects are recursive lists with \verb{2 x n} numeric matrices or empty lists as
terminal leaves.  The matrices contain the X-Y coordinates of the ordered
\code{n} endpoints of the \code{n - 1} line segments that the polygon or path
representation of the SVG elements comprise.  The empty lists correspond to
elements that could not be processed or simply branches without a
displayable terminal object.  The "svg_chopped_list" object may have an
"url" attribute which is a list named by the ids of "gradient" and other
objects that may be referenced via "url(#id)" values for "style-computed"
attributes (see Styling section).
}
\description{
Parse and convert SVG elements into polygons.  SVG transforms are applied to
the polygon coordinates, and SVG presentation attributes are computed from
style sheets, inline styles and attributes, and are attached as the
"style-computed" R attribute.  The SVG 1.1 specification is only loosely
followed so do not expect outputs to be exactly the same as in a conforming
SVG rendering engine.  This function is experimental and the API and
structure of the return value will likely change in future versions.  The
code is optimized neither for speed nor size of output.
}
\section{Details}{


The primary objective of this function is to compute vertex coordinates for
polygons and polylines that approximate SVG display elements so that they may
be used elsewhere.  In particular, we wrote this code to make it easier to
render extruded SVG objects in 3D with
\href{https://cran.r-project.org/package=rayrender}{\code{rayrender}}.  See the
implementation of the \code{plot.svg_chopped} for ideas on how to extract the data
for your own use.

In addition to vertex coordinates, this function will attempt to compute
styles using an approximation of SVG styling and CSS semantics for a
limited set of the styles (see the "Styling" section).

Almost all the data present in the SVG document is retained as part of the
recursive list structure of the return value.  In particular, the list
"incarnation" of each XML node will have "xml_name" and "xml_attrs"
attributes containing respectively the element name and attributes.  You can
retrieve them and parse them with your own logic if so desired.
}

\section{Lengths}{


All lengths and coordinates are assumed to be unit-less.  In other words
"px", "em", "cm", "\%", etc. values are completely ignored, except for "\%"
measures for the "offset" attribute to gradient stops.  Future releases may
switch to preserving units with e.g. \code{\link[grid:unit]{grid::unit()}}.
}

\section{Elements}{


Currently svg "path", "rect", "polygon", "circle", and "ellipse"  elements
are supported to varying degrees.  Every command for "path" in the SVG 1.1
spec is implemented (MZLHVCSQTA, and the relative equivalents).  "rect" does
not support rounded corners, and "ellipse" does not support "auto" values for
"rx" and "ry" (that is the default, but we assume 0).  "pathLength" is not
supported on any element.

"g" elements act as containers for child elements and convey their properties
to them.

The "use" element is supported, but only if the "xlink:href" or "href"
elements point to the id of an element within the same document.  Support is
also non-conforming (not that anything in this package is truly
conforming...) as CSS selector matching behaves as if the cloned copy of the
object were a full DOM child of the "use" element.  However, this
non-conformance is likely superseded by the very limited CSS selector
implementation (see "Styling" section).  The "use" element will be treated
as if it were a "g" element with the referenced element as a child and the
"x" and "y" attributes specified as a translate transform.

Elements not explicitly referenced here are not directly supported and how
they are processed is not specified.  Generally though such elements with
children will behave like "g" elements, and those without will be omitted.
}

\section{Transforms}{


Only SVG transforms are supported (i.e. not CSS ones).  The transform
attribute of every element in the SVG is read, parsed, and accumulated
through element generations.  It is then applied to the computed coordinates
of the terminal nodes.  You may turn off the application of the transforms by
setting \code{transform=FALSE}, in which case you will be responsible for
retrieving the transform data from the "transform-computed" attribute of the
terminal leaves of the "svg_chopped" objects.  This attribute will be a
"trans" S3 object containing the transformation matrix as the "mx" member and
the commands that were processed to produce that matrix as the "cmds" member.
}

\section{Styling}{


Style attributes attached directly to elements, whether as "style" attributes
or explicitly as e.g. a "fill" attribute, are parsed and interpreted.  CSS
styles are also processed, but support is limited to direct match
lookups on ASCII class-only and id-only selectors (i.e. no hierarchies,
properties, etc.).

CSS support is likely to be particularly fragile as the CSS parsing is regex
based and only simple ASCII-only class and id selectors are supported.

Styles, classes, and ids are accumulated through element generations and
computed into the "styles-computed" attribute of the terminal nodes, which is
a list with scalar elements representing the computed style values.  Missing
or uncomputable styles are reported as NA.  The computation is \emph{intended} to
mimic how browsers would interpret style, although on a limited basis that is
likely incorrect in many cases.

Fill and stroke values, with three exceptions, are returned as 6 digit
hex-codes or NA so that it is easy to append alpha values derived from the
opacity values.  Supported color formats are 6 digit hex, 3 digit hex, named
colors in \code{\link[graphics:colors]{graphics::colors()}}, and those in \code{rgb(x,y,z)} where \code{x}, \code{y}, and
\code{z} are numeric or percentage values as per the CSS spec.  Colors "none" and
"transparent" are both returned as "none" so that they may be distinguished
from unspecified color (those are NA).  \verb{url(#id)} values are returned as is.
Supported external styling such as gradients will be recorded as part of the
"svg_chopped_list" object and may be retrieved with the \code{\link[=svg_url]{svg_url()}} function.

Opacity is accumulated through generations and applied to the terminal
elements as the product of all accumulated opacity values.  If an element
specifies both "opacity" and "stroke-opacity" or "fill-opacity", the latter
two are multiplied with the value of "opacity".  Since the "opacity" value is
thus reflected in "stroke-opacity" and "style-opacity" it is dropped to avoid
confusion.
}

\section{Gradients}{


Both linear and radial gradients have limited support.  Gradients are parsed
and stop style is computed based on where they are defined.  "href" or
"xlink:href" attributes are not followed.  Gradients are attached as members
of the "url" attribute of the return value.  All the gradient coordinate
values (e.g. "x", "y", "cx", "cy", ...) are assumed to be specified in [0,
1], and not as percentages.

Unlike with typical opacity attributes "stop-opacity" is not accumulated
nor affected by any parent element "opacity" values, under the assumption
that "stop" elements are unlikely to be nested.

"gradientTransform" is computed into a transformation matrix, but nothing
else is done with it.
}

\section{Patterns, Masks, and Clip Paths}{


These are collected under the "url" attribute of the return value, and while
they may be processed in some way or other, it is not specified how.  More
support for these instructions may be added in the future.  Or not.
}

\examples{
svg <- process_svg(file.path(R.home(), 'doc', 'html', 'Rlogo.svg'))
if(interactive()) plot(svg)
}
\seealso{
\code{\link[=plot.svg]{plot.svg()}}
}
