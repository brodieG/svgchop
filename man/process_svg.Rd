% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse.R
\name{process_svg}
\alias{process_svg}
\title{Convert SVG Elements to Polygons or Polylines}
\usage{
process_svg(file, steps = 10, transform = TRUE)
}
\arguments{
\item{file}{an HTML or other XML based text file containing SVG elements.}

\item{steps}{integer(1L) > 0, how many line segments to use to approximate
Bézier curves, arcs, ellipses, and circles.  For Bézier curves, it is how
many segment each individual curve gets, so sequences of Bézier curves will
get that many for each curve in the sequence.  For arcs, ellipses, and
circles, it is how many segments per 180 degrees of arc.  The hope is that
in the future this parameter will be deprecated in favor of tolerance
based ones.}

\item{transform}{TRUE (default) or FALSE whether to apply the transformation
to the computed element coordinates.}
}
\value{
an "svg_chopped_list" S3 object, which is a list of "svg_chopped"
objects.  See "Details".
}
\description{
Parse and convert SVG elements into polygons.  SVG transforms are applied to
the polygon coordinates, and SVG presentation attributes are computed from
style sheets, inline styles and attributes, and are attached as the
"style-computed" R attribute.  The SVG 1.1 specification is only loosely
followed so do not expect outputs to be exactly the same as in a conforming
SVG rendering engine.  This function is experimental and the API and
structure of the return value will likely change in future versions.  The
code is optimized neither for speed nor memory use.
}
\section{Details}{


The primary objective of this function is to compute vertex coordinates for
polygons and polylines that approximate SVG display elements so that they may
be used elsewhere.  We wrote this code to make it easier to render extruded
SVG objects in 3D with
\href{https://cran.r-project.org/package=rayrender}{\code{rayrender}}.  See the
implementation of the \code{plot.svg_chopped} for ideas on how to extract the data
for your own use.

In addition to vertex coordinates, this function will attempt to compute
styles using an approximation of SVG styling and CSS semantics for a
limited set of the styles (see the "Styling" section).

The return value is an "svg_chopped_list" object, a list of
"svg_chopped" objects with some additional meta data attached as attributes.
Because HTML documents may contain multiple top level SVG viewports this
function always returns an "svg_chopped_list", even for the common case where
there is only one viewport.

Each "svg_chopped" object is a recursive list representing a top-level SVG
viewport.  If the leaves of the tree are known display elements they will
appear as \verb{2 x n} numeric matrices.  The matrices contain the X-Y coordinates
of the ordered \code{n} endpoints of the \code{n - 1} line segments that the polygon or
path representation of the SVG elements comprise.  These matrices may have
attributes attached that modify how they should be interpreted.  See
"Elements" section.  If the leaves are not known display elements they will
appear as empty lists.  There may be terminal elements that are neither lists
nor matrices (e.g. gradient "stop"s).

SVG meta data such as style sheets, gradients, patterns, may be removed from
the recursive structure and either re-inserted as attributes to relevant
child nodes, or stored under the "url" attribute of the "svg_chopped" and
"svg_chopped_list" objects.  This "url" attribute will be the same for the
"svg_chopped_list" object and all its child "svg_chopped" objects.  See the
"Styling", "Gradients", and "Patterns, Masks, and Clip Paths" sections for
more discussion of this.

Almost all the data present in the SVG document is retained as part of the
recursive list structure of the return value.  In particular, the list
"incarnation" of each XML node will have "xml_name" and "xml_attrs"
attributes containing respectively the element name and attributes.  You can
retrieve them and parse them with your own logic if so desired.
}

\section{Lengths}{


All lengths and coordinates are assumed to be unit-less except for the
"width" and "height" attributes on the top-level SVG elements, and the
"offset" attribute for gradient stops.  In other words for most elements
"px", "em", "cm", "\%", etc. values are completely ignored with all lengths
assumed to be in user coordinate system units.

The "width" and "height" attributes of the top-level SVG elements will be
interpreted as display device percentages if "\%" units are used, or pixels if
they are not.  The "offset" attribute to gradient stops will be interpreted
as percentages if "\%" units are used, or as unit-less numbers otherwise.

Future releases may switch to preserving units with e.g. \code{\link[grid:unit]{grid::unit()}}.
}

\section{Elements}{


The basic elements "line", "rect", "polygon", "polyline", "circle",
"ellipse", and "path" (with all commands in the SVG 1.1 spec) are
implemented.  "rect" does not support rounded corners, and "ellipse" does not
support "auto" values for "rx" and "ry" (that is the default, but we assume
0).  "pathLength" is not supported on any element.

XML attribute data is processed to compute x and y coordinates for a set of
vertices that approximates the outline of each element.  These are stored as
2 x n matrices.  The attribute "closed" will be set to a logical vector
representing whether the element should be interpreted as a closed polygon or
as an open "polyline".  "path" elements may contain sub-paths, and the
"closed" vector will contain one entry for each sub-path.  The starting
column in the coordinate matrix for each sub-path is recorded in the "starts"
attribute.

"g" elements act as containers for child elements and convey their properties
to them.

The "use" element is supported, but only if the "xlink:href" or "href"
elements point to the id of an element within the same document.  Support is
also non-conforming (not that anything in this package is truly
conforming...) as CSS selector matching behaves as if the cloned copy of the
object were a full DOM child of the "use" element.  However, this
non-conformance is likely superseded by the very limited CSS selector
implementation (see "Styling" section).  The "use" element will be treated
as if it were a "g" element with the referenced element as a child and the
"x" and "y" attributes specified as a translate transform.

Elements not explicitly referenced here are not directly supported and how
they are processed is not specified.  Generally though such elements with
children will behave like "g" elements, and those without will be omitted.
}

\section{Transforms}{


Only SVG transforms are supported (i.e. not CSS ones).  The transform
attribute of every element in the SVG is read, parsed, and accumulated
through element generations.  It is then applied to the computed coordinates
of the terminal nodes.  You may turn off the application of the transforms by
setting \code{transform=FALSE}, in which case you will be responsible for
retrieving the transform data from the "transform-computed" attribute of the
terminal leaves of the "svg_chopped" objects.  This attribute will be a
"trans" S3 object containing the transformation matrix as the "mx" member and
the commands that were processed to produce that matrix as the "cmds" member.

The rendering agent will be responsible for scaling stroke.  For
\code{\link[=plot.svg_chopped]{plot.svg_chopped()}} we use the average of the absolute scaling factors from
the computed transformation matrix.
}

\section{Styling}{


A subset of the \href{https://www.w3.org/TR/SVG11/styling.html#SVGStylingProperties}{SVG 1.1 styling properties}
is explicitly computed from the SVG data (see \code{\link[=styles_computed]{styles_computed()}} for the
list).  Values are taken from the properties defined in-line in the SVG
elements or its ancestors, CSS style sheets, and in-line "style" properties.
CSS selector support is limited to direct match lookups on
"&#lt;element>.<class>" or "<element>#<id>" where "*"
may be used as a wild card.  Selector hierarchies, properties, or anything
other than basic selectors is not supported.  For example, the following
selectors are supported:
\itemize{
\item "*"
\item "*.class"
\item "rect.class"
\item "rect#id"
\item ".class"
\item "#id"
}

But these are not:
\itemize{
\item "g class"        (element of class "class" a descendant of a "g" element)
\item "*.class.klass"  (two classes)
}

Style sheets are parsed with regex, so parsing may fail if you have
particularly pathological text therein.

Styles, classes, and ids are accumulated through element generations and
computed into the "styles-computed" attribute of the terminal nodes, which is
a list with scalar elements representing the computed style values.  Missing
or uncomputable styles are reported as NA, except in the cases where the spec
defines default values or it is convenient for us to assert a default.
Default values will have class "default".  The computation is an
approximation of what the spec mandates.

Fill and stroke values, with three exceptions, are returned as 6 digit
hex-codes or NA so that it is easy to append alpha values derived from the
opacity values.  Supported color formats are 6 digit hex, 3 digit hex, named
colors in \code{\link[=svg_colors_all]{svg_colors_all()}} (the 147 named SVG 1.1 colors), and \code{rgb(x,y,z)}
where \code{x}, \code{y}, and \code{z} are numeric or percentage values as per the CSS spec.
\verb{url(#id)} values are returned as is.  Supported external styling such as
gradients will be recorded in the "url" attribute of the "svg_chopped_list"
and "svg_chopoped" objects.

If an element specifies both "opacity" and "stroke-opacity" or
"fill-opacity", the latter two are multiplied with the value of "opacity".
Since the "opacity" value is thus reflected in "stroke-opacity" and
"style-opacity" it is dropped to avoid confusion.
}

\section{Gradients}{


Both linear and radial gradients have limited support.  Gradients are parsed
and stop style is computed based on where they are defined.  "href" or
"xlink:href" attributes are not followed.  Gradients are attached as members
of the "url" attribute of the return value.  All the gradient coordinate
values (e.g. "x", "y", "cx", "cy", ...) are assumed to be specified in [0,
1], and not as percentages.

Unlike with typical opacity attributes "stop-opacity" is not accumulated
nor affected by any parent element "opacity" values, under the assumption
that "stop" elements are unlikely to be nested.

"gradientTransform" is computed into a transformation matrix, but nothing
else is done with it.

The \code{plot} method for "svg_chopped" objects will use \code{\link[=approximate_color]{approximate_color()}} to
compute a single color from the gradient data.
}

\section{Patterns, Masks, and Clip Paths}{


These are collected under the "url" attribute of the return value, and while
they may be processed in some way or other, it is not specified how.  More
support for these instructions may be added in the future.  Or not.
}

\examples{
svg <- process_svg(file.path(R.home(), 'doc', 'html', 'Rlogo.svg'))
if(interactive()) plot(svg)
}
\seealso{
\code{\link[=plot.svg]{plot.svg()}}, \code{\link[=flatten]{flatten()}} for an easier-to-manage data structure,
\code{\link[=styles_computed]{styles_computed()}} for what styles are actively processed.
}
